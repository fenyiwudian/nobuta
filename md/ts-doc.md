
+ 之前在写core的时候把类型都抽出到了单独的index.d.ts中.它不作为一个模块,而是作为全局类型声明文件,这样每个模块中引用这些类型时,不需要显示导入,可以偷点懒,也能避免文件开头大量的模块导入声明.

+ 这样做的话就要求所有的会跨模块用到的类型,都放到index.d.ts中,因为index.d.ts不做为一个模块,他不能去引用其他模块的类型.

+ 这样做对于写文档也方便,所有文档同一写在index.d.ts的注释中,最后用typedoc生成即可.

+ 但是如果这时候用到了typescript的枚举,就会变得很糟糕了,因为非模块中不能定义实际枚举,他其中`declare enum`定义的只是类型枚举,在其他模块中如果直接使用了这个枚举,会导致编译通过,但是运行的时候,其实是没有这个枚举类型的,就会出错.

+ 如果将枚举定义到模块中,也可能行不通,因为index.d.ts中的某些接口的某些属性可能是一个枚举类型,这时候它有必须要引用这个枚举,但是就违反了它不做为模块的原则.

+ 综上考虑,还是回到全部都是模块的方式,类型也定义在相关的功能模块中,其他模块用到该类型就显示导入.我们在这里才测试一下能不能达到完美导出文档的效果.

+ 功能模块可以和类型定义模块分离,因为大部分功能模块中的注释不做为最后的文档,我们生成文档的时候只挑选对类型定义模块生成即可.如果某些功能模块的注释也要当做文档数值,则生成文档的命令中包含它即可.

+ 时候用typedoc的`library`模式生成文档,则只会把导出对象的注释当成文档输出,未导出对象的注释不会输出.这正是我要的功能.

+ 当前typedoc的library功能可以使用,但是还有些问题,所以主仓库包中并没有合并该该功能,我使用的是[其他人fork的仓库发出的包](https://www.npmjs.com/package/@paztis/typedoc),等后续主仓库修复各种问题,正式发布后转为使用主仓库的包.

+ tsconfig.json中未包含`"moduleResolution": "node"`设置的时候,生成文档会出错,提示找不到node_modules中的某些类型定义,这个原因未知,后续需要调查,现在反正加上这个配置后,可以正常生成.