/**
 * 选择排序
 * 本质：选择排序
 * 分有序部分和无序部分两块
 * 初始状态全部都是无序部分，每排完一趟有序部分增长一位，无序部分减少一位
 * 每一趟开始时假设以无序部分第一个为最小，然后遍历无序部分得到真正最小的
 * 然后无序第一个和最小的换位，就完成了该趟排序，有序加一位，无序减一位
 */
Array.prototype.selectSort = function(a) {
    var temp, min, i, j;
    for(i = 0; i < this.length - 1; i++){
        // 初始假设第一个为最小
        min = i;
        // 尝试往后找更小的
        for(j = i + 1; j < this.length; j++){
            // 找到更小的
            if(this[j] < this[min]){
                // 更换最小的
                min = j;
            }
        }
        // 找完了后让最小的和当前位置更换位置
        temp = this[min];
        this[min] = this[i];
        this[i] = temp;
    }
}

/**
 * 冒泡排序
 * 本质：交换排序
 * 末尾一部分为冒好泡的有序部分，开始一段为即将冒泡的无序部分
 * 初始状态下全是无序部分，每进行一趟冒泡无序部分减少一个元素，有序部分增加一个元素
 * 冒泡过程中碰到比自己小的，继续往上冒，
 * 遇到比自己大的自己停下，让比自己大的那个接着冒
 */
Array.prototype.bubbleSort = function () {
    var temp, i, j;
    for (i = 0; i < this.length - 1; i++) {
        // 从前往后取一个开始冒泡
        for (var j = 0; j < this.length - 1 - i; i++) {
            // 碰到比自己小的
            if (this[j] > this[j + 1]) {
                // 往上冒
                temp = this[j];
                this[j] = this[j + 1];
                this[j + 1] = temp;
            }
            // 碰到比自己大的，啥都不干自己停下
            // 下一轮让比自己大的家伙冒泡
        }
    }
}

/**
 * 直接插入排序
 * 本质：插入排序
 * 概念上分为有序的一部分和无序的一部分，如果从前往后处理的话，
 * 则开头一部分为有序，后面一部分为无序，
 * 初始场合第一个元素被当成有序部分，其余部分为无序的。
 * 每一趟都是拿出无序部分的第一个往有序部分插入，够小则插入中间或前面，够大则跟在后面
 * 每完成一趟则有序部分向后扩张一个位置，无序部分向后缩减一个位置
 * 直到所有都有序，完成排序。
 */
Array.prototype.insertSort = function () {
    var temp, i, j;
    // 第零个元素无论是什么都可以认为是有序的
    // 遍历1-n个元素（这些元素现在还是无序的）
    // 我们拿出每个元素尝试往有序的一部分中插入
    // 一次循环为一趟排序
    for (i = 1; i < this.length; i++) {
        // 记下当前元素，这是无序部分的第一个元素
        // 我们要把该元素拿出来尝试插入到之前的位置
        temp = this[i];
        // 以从后往前的顺序和有序部分的每个元素进行比较，
        // 够小则和前一个换位，直到遇到不比自己小的结束该趟
        for (j = i - 1; j >= 0 && this[j] > temp; j--) {
            this[j + 1] = this[j];
        }
        // 移不动了一趟结束，缓存放在最后比较的位置
        this[j + 1] = temp;
    }
}

/**
 * 希尔排序
 * 本质：交换排序
 * 按步长分组优化直接插入排序
 * 步长：分组的长度，每一趟的步长是不一样的，都比前一趟小，步长尽量不要成倍数关系
 * 否则下次分组分到的组其实是上次分组得到的组的再分割，然后再排序没意义，因为已经排好了。
 * 按步长分组，但是分组的元素都不是连续的，而是按步长跳跃取得。
 * 然后对每个分组进行插入排序，可以让元素进行大跨度的调整位置，尽快让元素跑到该到的位置，
 * 下一趟用新的更小的步长再分组，再组内排序，进一步接近最后结果，
 * 到最后一趟步长为1，就是进行普通的插入排序，
 * 但此时经过前几趟的组内大跨度跳跃，该数组已经基本有序
 * 而直接插入排序对于基本有序的数组效率非常高，
 * 综合下来在直接插入排序的基础上提升了速度
 */
Array.prototype.shellSort = function () {
    var temp, i, j;
    // 步长可自定，一般有公式生成每一趟的步长（还有最优步长计算公式，具体维基百科查找）
    // 该例子中我们简单的用除以2向下取整生成每一趟的步长
    for (var gap = this.length >> 1; gap > 0; gap >>= 1) {
        // 对每一组进行直接插入排序
        // 直接插入排序中第一个元素默认为有序，从第二个元素开始
        // 所以对于我们跨步长分组中我们步长索引处的元素（正好是第一组的第二个元素）开始
        for (i = gap; i < len; i++) {
            // 缓存起该位置的元素
            temp = this[i];
            // 跨步和组内前一个元素进行比较
            for (j = i - gap; j >= 0 && this[j] > temp; j -= gap) {
                // 前一个元素太大则移到后面位置
                this[j + gap] = this[j];
            }
            // 无法再移动了说明该位置已经够小了
            // 就把缓存的元素的放在
            this[j + gap] = temp;
        }
    }
}
